---
title: 'A guide to EEPROM'
description: 'Learn how to use EEPROM, short for electrically erasable programmable read-only memory, on Arduino boards.'
tags: [EEPROM, Memory]
---

The microcontroller on the Arduino boards have 512 bytes of [EEPROM:](http://en.wikipedia.org/wiki/EEPROM) memory whose values are kept when the board is turned off (like a tiny hard drive).

Functions in the **EEPROM** class is automatically included with the platform for your board, meaning you do not need to install any external libraries. 

## Hardware Required

All of the following boards have an EEPROM:
- [Arduino UNO R4 Minima](https://store.arduino.cc/products/uno-r4-minima)
- [Arduino UNO R4 WiFi](https://store.arduino.cc/products/uno-r4-wifi)
- [Arduino UNO Rev.3](https://store.arduino.cc/products/arduino-uno-rev3/)
- [Arduino UNO WiFi Rev.2](https://store.arduino.cc/arduino-uno-wiFi-rev2)
- [Arduino Mega 2560 Rev.3](https://store.arduino.cc/products/arduino-mega-2560-rev3)
- [Arduino Nano Every](https://store.arduino.cc/products/arduino-nano-every)
- [Arduino Micro](https://store.arduino.cc/products/arduino-micro)
- [Arduino Leonardo](https://store.arduino.cc/products/arduino-leonardo-with-headers)
- [Arduino Nano](https://store.arduino.cc/products/arduino-nano)

## EEPROM Clear

This example illustrates how to set of all of those bytes to 0, initializing them to hold new information, using the EEPROM.write() function.

```arduino
/*
 * EEPROM Clear
 *
 * Sets all of the bytes of the EEPROM to 0.
 * Please see eeprom_iteration for a more in depth
 * look at how to traverse the EEPROM.
 *
 * This example code is in the public domain.
 */

#include <EEPROM.h>

void setup() {
  // initialize the LED pin as an output.
  pinMode(13, OUTPUT);
  
  /***
    Iterate through each byte of the EEPROM storage.
    Larger AVR processors have larger EEPROM sizes, E.g:
    - Arduino Duemilanove: 512 B EEPROM storage.
    - Arduino Uno:         1 kB EEPROM storage.
    - Arduino Mega:        4 kB EEPROM storage.
    Rather than hard-coding the length, you should use the pre-provided length function.
    This will make your code portable to all AVR processors.
  ***/

  for (int i = 0 ; i < EEPROM.length() ; i++) {
    EEPROM.write(i, 0);
  }

  // turn the LED on when we're done
  digitalWrite(13, HIGH);
}

void loop() {
  /** Empty loop. **/
}
```

## EEPROM CRC

A [CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) is a simple way of checking whether data has changed or become corrupted. This example calculates a CRC value directly on the EEPROM values. This CRC is like a signature and any change in the calculated CRC means a change in the stored data. The purpose of this example is to highlight how the EEPROM object can be used just like an array.

```arduino
/***

    Written by Christopher Andrews.

    CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ).

    A CRC is a simple way of checking whether data has changed or become corrupted.

    This example calculates a CRC value directly on the EEPROM values.

    The purpose of this example is to highlight how the EEPROM object can be used just like an array.

***/

#include <Arduino.h>
#include <EEPROM.h>

void setup() {

  //Start serial

  Serial.begin(9600);

  while (!Serial) {

    ; // wait for serial port to connect. Needed for native USB port only

  }

  //Print length of data to run CRC on.

  Serial.print("EEPROM length: ");

  Serial.println(EEPROM.length());

  //Print the result of calling eeprom_crc()

  Serial.print("CRC32 of EEPROM data: 0x");

  Serial.println(eeprom_crc(), HEX);

  Serial.print("\n\nDone!");
}

void loop() {

  /* Empty loop */
}

unsigned long eeprom_crc(void) {

  const unsigned long crc_table[16] = {

    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,

    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,

    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,

    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c

  };

  unsigned long crc = ~0L;

  for (int index = 0 ; index < EEPROM.length()  ; ++index) {

    crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4);

    crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4);

    crc = ~crc;

  }

  return crc;
}
```

## EEPROM Get

The purpose of this example is to show how the put and get methods provide a different behaviour than write and read, that work on single bytes. Getting different variables from EEPROM retrieve a number of bytes that is related to the variable datatype.

```arduino
/***

    eeprom_get example.

    This shows how to use the EEPROM.get() method.

    To pre-set the EEPROM data, run the example sketch eeprom_put.

    This sketch will run without it, however, the values shown

    will be shown from what ever is already on the EEPROM.

    This may cause the serial object to print out a large string

    of garbage if there is no null character inside one of the strings

    loaded.

    Written by Christopher Andrews 2015

    Released under MIT licence.

***/

#include <EEPROM.h>

void setup() {

  float f = 0.00f;   //Variable to store data read from EEPROM.

  int eeAddress = 0; //EEPROM address to start reading from

  Serial.begin(9600);

  while (!Serial) {

    ; // wait for serial port to connect. Needed for native USB port only

  }

  Serial.print("Read float from EEPROM: ");

  //Get the float data from the EEPROM at position 'eeAddress'

  EEPROM.get(eeAddress, f);

  Serial.println(f, 3);    //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float.

  /***

    As get also returns a reference to 'f', you can use it inline.

    E.g: Serial.print( EEPROM.get( eeAddress, f ) );

  ***/

  /***

    Get can be used with custom structures too.

    I have separated this into an extra function.

  ***/

  secondTest(); //Run the next test.
}

struct MyObject {

  float field1;

  byte field2;

  char name[10];
};

void secondTest() {

  int eeAddress = sizeof(float); //Move address to the next byte after float 'f'.

  MyObject customVar; //Variable to store custom object read from EEPROM.

  EEPROM.get(eeAddress, customVar);

  Serial.println("Read custom object from EEPROM: ");

  Serial.println(customVar.field1);

  Serial.println(customVar.field2);

  Serial.println(customVar.name);
}

void loop() {

  /* Empty loop */
}
```

## EEPROM Iteration

The purpose of this example is to show how to go through the whole EEPROM memory space with different approaches. The code provided doesn't run on its own but should be used as a surce of code snippets to be used elsewhere.

```arduino
/***

    eeprom_iteration example.

    A set of example snippets highlighting the

    simplest methods for traversing the EEPROM.

    Running this sketch is not necessary, this is

    simply highlighting certain programming methods.

    Written by Christopher Andrews 2015

    Released under MIT licence.

***/

#include <EEPROM.h>

void setup() {

  /***

    Iterate the EEPROM using a for loop.

  ***/

  for (int index = 0 ; index < EEPROM.length() ; index++) {

    //Add one to each cell in the EEPROM

    EEPROM[ index ] += 1;

  }

  /***

    Iterate the EEPROM using a while loop.

  ***/

  int index = 0;

  while (index < EEPROM.length()) {

    //Add one to each cell in the EEPROM

    EEPROM[ index ] += 1;

    index++;

  }

  /***

    Iterate the EEPROM using a do-while loop.

  ***/

  int idx = 0;  //Used 'idx' to avoid name conflict with 'index' above.

  do {

    //Add one to each cell in the EEPROM

    EEPROM[ idx ] += 1;

    idx++;

  } while (idx < EEPROM.length());

} //End of setup function.

void loop() {}
```

## EEPROM Put

The purpose of this example is to show the `EEPROM.put()` method that writes data on EEPROM using also the EEPROM.update() that writes data only if it is different from the previous content of the locations to be written. The number of bytes written is related to the datatype or custom structure of the variable to be written.


```arduino
/***

    eeprom_put example.

    This shows how to use the EEPROM.put() method.

    Also, this sketch will pre-set the EEPROM data for the

    example sketch eeprom_get.

    Note, unlike the single byte version EEPROM.write(),

    the put method will use update semantics. As in a byte

    will only be written to the EEPROM if the data is actually

    different.

    Written by Christopher Andrews 2015

    Released under MIT licence.

***/

#include <EEPROM.h>

struct MyObject {

  float field1;

  byte field2;

  char name[10];
};

void setup() {

  Serial.begin(9600);

  while (!Serial) {

    ; // wait for serial port to connect. Needed for native USB port only

  }

  float f = 123.456f;  //Variable to store in EEPROM.

  int eeAddress = 0;   //Location we want the data to be put.

  //One simple call, with the address first and the object second.

  EEPROM.put(eeAddress, f);

  Serial.println("Written float data type!");

  /** Put is designed for use with custom structures also. **/

  //Data to store.

  MyObject customVar = {

    3.14f,

    65,

    "Working!"

  };

  eeAddress += sizeof(float); //Move address to the next byte after float 'f'.

  EEPROM.put(eeAddress, customVar);

  Serial.print("Written custom data type! \n\nView the example sketch eeprom_get to see how you can retrieve the values!");
}

void loop() {

  /* Empty loop */
}
```

## EEPROM Read

This example illustrates how to read the value of each byte EEPROM using the `EEPROM.read()` function, and how to print those values to the serial window of the Arduino Software (IDE).


```arduino
/*
 * EEPROM Read
 *
 * Reads the value of each byte of the EEPROM and prints it
 * to the computer.
 * This example code is in the public domain.
 */

#include <EEPROM.h>

// start reading from the first byte (address 0) of the EEPROM
int address = 0;
byte value;

void setup() {
  // initialize serial and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
}

void loop() {
  // read a byte from the current address of the EEPROM
  value = EEPROM.read(address);

  Serial.print(address);
  Serial.print("\t");
  Serial.print(value, DEC);
  Serial.println();

  /***
    Advance to the next address, when at the end restart at the beginning.

    Larger AVR processors have larger EEPROM sizes, E.g:
    - Arduino Duemilanove: 512 B EEPROM storage.
    - Arduino Uno:         1 kB EEPROM storage.
    - Arduino Mega:        4 kB EEPROM storage.

    Rather than hard-coding the length, you should use the pre-provided length function.
    This will make your code portable to all AVR processors.
  ***/
  address = address + 1;
  if (address == EEPROM.length()) {
    address = 0;
  }

  /***
    As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an
    EEPROM address is also doable by a bitwise and of the length - 1.

    ++address &= EEPROM.length() - 1;
  ***/

  delay(500);
}
```

## EEPROM Update

The purpose of this example is to show the `EEPROM.update()` method that writes data only if it is different from the previous content of the locations to be written. This solution may save execution time because every write operation takes 3.3 ms; the EEPROM has also a limit of 100,000 write cycles per single location, therefore avoiding rewriting the same value in any location will increase the EEPROM overall life.

```arduino
/***
   EEPROM Update method

   Stores values read from analog input 0 into the EEPROM.
   These values will stay in the EEPROM when the board is
   turned off and may be retrieved later by another sketch.

   If a value has not changed in the EEPROM, it is not overwritten
   which would reduce the life span of the EEPROM unnecessarily.

   Released using MIT licence.
 ***/

#include <EEPROM.h>

/** the current address in the EEPROM (i.e. which byte we're going to write to next) **/
int address = 0;

void setup() {
  /** Empty setup **/
}

void loop() {
  /***
    need to divide by 4 because analog inputs range from
    0 to 1023 and each byte of the EEPROM can only hold a
    value from 0 to 255.
  ***/
  int val = analogRead(0) / 4;

  /***
    Update the particular EEPROM cell.
    these values will remain there when the board is
    turned off.
  ***/
  EEPROM.update(address, val);

  /***
    The function EEPROM.update(address, val) is equivalent to the following:

    if( EEPROM.read(address) != val ){
      EEPROM.write(address, val);
    }
  ***/


  /***
    Advance to the next address, when at the end restart at the beginning.

    Larger AVR processors have larger EEPROM sizes, E.g:
    - Arduino Duemilanove: 512 B EEPROM storage.
    - Arduino Uno:         1 kB EEPROM storage.
    - Arduino Mega:        4 kB EEPROM storage.

    Rather than hard-coding the length, you should use the pre-provided length function.
    This will make your code portable to all AVR processors.
  ***/
  address = address + 1;
  if (address == EEPROM.length()) {
    address = 0;
  }

  /***
    As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an
    EEPROM address is also doable by a bitwise and of the length - 1.

    ++address &= EEPROM.length() - 1;
  ***/

  delay(100);
}
```

## EEPROM Write

This example illustrates how to store values read from analog input 0 into the EEPROM using the `EEPROM.write()` function.  These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch.

```arduino
/*

 * EEPROM Write

 *

 * Stores values read from analog input 0 into the EEPROM.

 * These values will stay in the EEPROM when the board is

 * turned off and may be retrieved later by another sketch.

 */

#include <EEPROM.h>

/** the current address in the EEPROM (i.e. which byte we're going to write to next) **/
int addr = 0;

void setup() {

  /** Empty setup. **/
}

void loop() {

  /***

    Need to divide by 4 because analog inputs range from

    0 to 1023 and each byte of the EEPROM can only hold a

    value from 0 to 255.

  ***/

  int val = analogRead(0) / 4;

  /***

    Write the value to the appropriate byte of the EEPROM.

    these values will remain there when the board is

    turned off.

  ***/

  EEPROM.write(addr, val);

  /***

    Advance to the next address, when at the end restart at the beginning.

    Larger AVR processors have larger EEPROM sizes, E.g:

    - Arduno Duemilanove: 512b EEPROM storage.

    - Arduino Uno:        1kb EEPROM storage.

    - Arduino Mega:       4kb EEPROM storage.

    Rather than hard-coding the length, you should use the pre-provided length function.

    This will make your code portable to all AVR processors.

  ***/

  addr = addr + 1;

  if (addr == EEPROM.length()) {

    addr = 0;

  }

  /***

    As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an

    EEPROM address is also doable by a bitwise and of the length - 1.

    ++addr &= EEPROM.length() - 1;

  ***/

  delay(100);
}
```
